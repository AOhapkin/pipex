# pipex

## Описание

Pipex — это программа, которая принимает на вход названия файлов и произвольные shell-команды.

Задача написать программу на языке C, которая будет вызываться следующим образом:

```./pipex file1 cmd1 cmd2 file2```

---

У программы должно быть 4 аргумента:

* `file1` и `file2` - названия файлов,
* `cmd1` и `cmd2` - shell-команды со своими параметрами.

---

Программа должна вести себя точно так же, как приведённая команда ниже:

`$> < file1 cmd1 | cmd2 > file2`

---

## Разрешенные функции

- `int open(const char *filename, int access, unsigned mode)` - открывает файл с именем filename и устанавливает доступ к нему согласно значению аргумента access (только чтение O_RDONLY и только запись O_WRONLY). Аргумент `mode` требуется только при модификаторе O_CREAT. Функция ореn() возвращает положительное целое число (дескриптор открытого файла) или -1, если не получается открыть файл.

- `int close(int fd)` - при действительном дескрипторе файла fd функция закрывает файл и очищает буфер, если необходимо. Возвращает 0, если успех, или -1.

- `int read(int fd, void *buf, unsigned count)` - считывает count байт из файла (дескриптор fd) в буфер buf. Возвращает количество действительно прочитанных байт (может быть меньше, чем count), -1 при ошибке и 0 при попытке чтения в конце файла.

- `void perror(const char *str)` - помещает значение глобальной переменной errno в строку и записывает её в файл stderr. Если (str != NULL), сначала выводится str, затем двоеточие и сообщение ошибки согласно errno.

- `char *strerror(int num)` - возвращает указатель на сообщение об ошибке, связанное с номером ошибки num (пример вызова strerror(errno)).

- `int access(const char *filename, int mode)` - используется для проверки существования файла filename. Может проверить на защиту от записи (mode: 2), является ли файл исполняемым (mode: 1), доступность для чтения (mode: 3). Возвращает 0, если проверяемый вид доступа разрешен, или -1, если нет.

- `int dup(int handle)` - возвращает новый дескриптор, который дублирует состояние файла, связанного с handle. Возвращается неотрицательная величина, если успех, или -1.
- `int dup2(int old_handle, int new_handle)` - дублирует old_handle как new_handle. Если был заранее открыт файл в new_handle, то он будет закрыт. Возвращает 0, если успех, и -1 при ошибке (и устанавшивает ошибки в errno).

- `int execve(char *filename, char *argv[ ], char *envp[ ])` - выполняет программу заданную параметром filename. Программа должна быть исполняемым файлом или скриптом вида `[arg] filename`. argv - массив строковых аргументов новой программы; envp - массив строк в формате key=value, которые передаются новой программе в качестве окружения (environment). Оба массива завершаются NULL. При успешном выполнении функции управление не возвращается, а код, данные и стек процесса перезаписываются заргуженной программой. При ошибке возвращает -1.

- `void exit(int status)` - обычное завершение работы программы. EXIT_SUCCESS и EXIT_FAILURE передают в exit() для обозначения соответственно успешного и неуспешного завершения. Ничего не возвращает.

- `pid_t fork(void)` - создает новый процесс (child process). pid_t примитивный тип данных, который опредеяет идентификатор процесса или группы процессов. Вызов fork() создает два идентичных процесса. Когда потомок вызывает exit(), код возврата передается родителю, который ожидает его, вызывая wait(). Функция `wait()` ждет завершения первого из всех возможных потомков родительского процесса.

- `pid_t wait(int *status)` - приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс не завершится.
`pid_t waitpid(pid_t pid, int *status, int options)` - приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, указанный в параметре pid, не завершит выполнение, или пока не появится сигнал, который либо завершает текущий процесс либо требует вызвать функцию-обработчик.
Обе функции возвращают идентификатор дочернего процесса, который завершил выполнение, возвращают 0, если ни один дочерний процесс ещё не доступен или -1, если ошибка.

- `int pipe (int filedes[2])` cоздает канал (связь между процессами). Данные, записывающиеся в канал одним процессом могут читаться другим процессом. При сздании канала pipe() помещает дескрипторы файла для чтения и записи (соответственно) в filedes[0] и filedes[1]. При успехе pipe возвращает значение 0. При отказе, -1 (с установлением значения в errno).

- `int unlink(const char *filename)` удаляет указанный файл из каталога. Ввозвращает 0 или -1 при неудаче (с установлением значения в errno).

- свой `ft_printf` (или написать любой другой аналог)

## Структура проекта

`Makefile, *.h, *.c`

Makefile должен содержать команды `$(NAME), all, clean, fclean и re`.

## Примеры вызова программы

---

```$> ./pipex infile "ls -l" "wc -l" outfile```
 
 Аналог: `< infile ls -l | wc -l > outfile`

 ---

```$> ./pipex infile "grep a1" "wc -w" outfile``` 

Аналог: `< infile grep a1 | wc -w > outfile`

---

## Требования

- Необходимо добавить Makefile, который скомпилирует все файлы. Перекомпиляция должна происходить только в случае необходимости.
- Необходимо обрабатывать все ошибки. Программа не должна завершаться неожиданно.
- Не должно быть утечек памяти.
- Ошибки должны быть обработаны как у shell-команды ```< file1 cmd1 | cmd2 > file2```

# Чек-лист для подготовки к защите

## Общая часть

- Все файлы должны быть в школьном репозитории
- Нет ошибок norminette
- Ошибки программы должны обрабатываться
- Мейкфайл собирает исполняемый файл и имеет необходимые правила
- Исполняемый файл называется `pipex`
- Нет запрещенных функций

## Основная часть

### Управление ошибками и аргументами

- Программа принимает только 4 аргумента (кроме бонусной части) и только в правльном порядке
- Правильная обработка ошибок: существование файлов, права на файлы, двоичный файл команды существует.

### Программа

- Программа делает то, что было запрошено без отображения никакой дополнительной информации
- Запустить тесты и сравнить результаты вывода программы и shell оболочки
